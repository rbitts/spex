#!/usr/bin/env node

"use strict";

var mysql = require('mysql');
var owjs = require('overwatch-js');
var async = require('async');
var syncSql = require('sync-sql');
var common = require('./common.js');

var HeroPlaceHolder = require('../HeroPlaceHolder.json');

const db_info = {
    host: 'localhost',
    user: '####',
    pass: 'password',
    port: '3306',
    password: '####',
    database: 'overwatch'
}

var connection = mysql.createConnection({
    host: 'localhost',
    port: 3306,
    user: '####',
    password: '####',
    database: 'overwatch'
});

const STATICS_TABLE = 'users';
const TODAY_TABLE = 'today';
const HISTORY_TABLE = 'history';
const TEAMINFO_TABLE = 'teaminfo';
const TEAMACTIVITY_TABLE = 'team_activity';
const HIGHLIGHT_TABLE = 'highlight';

const HISTORY_STACK = 6;

let StaticsProvider = function () {

    var self = this;

    connection.connect(function (err) {
        if (err) {
            console.log(err);
        }
    });

    /**
     * 사용자 조회용 API
     */

    self.getViewStaticsWithHistory = (nick, callback) => {
        let datas = [];

        let query = "SELECT * FROM ( " +
            "SELECT `U`.`sq` as 'seq', `U`.`id`, `U`.`rank`, `U`.`profile`, `U`.`competitive_global`, `U`.`quickplay_global`, `U`.`competitive`, `U`.`quickplay`, `U`.`date`, `U`.`timestamp` FROM " +
            "( SELECT IF(@score > `bt`.`rank`, @cur := @cur+1, @cur) AS 'sq', @score := `bt`.rank, `bt`.* " +
            " FROM `" + TODAY_TABLE + "` bt, (SELECT @cur := 0, @score := 5000) t " +
            "ORDER BY `bt`.`rank` DESC) U " +
            "WHERE `U`.`id` = '" + nick + "' " +
            "UNION " +
            "SELECT `seq`, `id`, `rank`, `profile`, `competitive_global`, `quickplay_global`, `competitive`, `quickplay`, `date`, `timestamp` " +
            "FROM `" + HISTORY_TABLE + "` " +
            "WHERE `id` = '" + nick + "' " +
            ") T " +
            "ORDER BY `T`.`date` DESC ";

        // console.log(query);

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }

            let currentTime = new Date().getTime() / 1000 | 0;

            for (let i = 0; i < rows.length; i++) {

                let json = JSON.parse(rows[i].profile);
                let data = {
                    seq: rows[i].seq,
                    nick: rows[i].id,
                    role: rows[i].role,
                    team: rows[i].team,
                    profile: JSON.parse(rows[i].profile),
                    competitive_global: (rows[i].competitive_global) ? JSON.parse(rows[i].competitive_global) : "",
                    competitive: JSON.parse(rows[i].competitive),
                    quickplay_global: (rows[i].quickplay_global) ? JSON.parse(rows[i].quickplay_global) : "",
                    quickplay: JSON.parse(rows[i].quickplay),
                    timestamp: " " + getTimeStampString(currentTime - rows[i].timestamp),
                    competitive_portrait: "",
                    quickplay_portrait: "",
                    date: rows[i].date,
                    hasCompetitive: false,
                }
                if (data.competitive.order[0] !== undefined) {
                    data.competitive_portrait = data.competitive.data[data.competitive.order[0].name].portrait;
                }

                data.quickplay_portrait = data.quickplay.data[data.quickplay.order[0].name].portrait;
                data.portrait = data.quickplay_portrait;

                if (data.profile.rank > 0) {
                    data.portrait = data.competitive.data[data.competitive.order[0].name].portrait;
                    data.hasCompetitive = true;
                }

                datas.push(data);
            }

            callback(null, datas);
        });
    };

    self.getViewStatics = (nick, callback) => {
        console.log('getViewStatics ' + nick);

        self.getViewStaticsWithHistory(nick, function (error, results) {
            if (error) {
                callback(error, null);
                return;
            }
            if (results.length === 0) {
                let error = {
                    status: 404,
                    message: 'user not found'
                }
                callback(error, null);
                return;
            }

            let data = results[0];
            callback(null, data);
        });
    };

    self.getStaticsRange = (draw, start, end, search, callback) => {
        // console.log('getStaticsRange ' + start + '-' + end + " : " + search);

        let data = {
            "draw": draw,
            "recordsTotal": 0,
            "recordsFiltered": 0,
            data: []
        };

        async.series([
                function (callback) {
                    let query = "SELECT COUNT(*) AS 'count' FROM `" + STATICS_TABLE + "`";

                    let result = connection.query(query, function (err, rows) {
                        for (let i = 0; i < rows.length; i++) {
                            callback(null, rows[i].count);
                        }
                    });
                },
                function (callback) {
                    let query = "SELECT COUNT(*) AS 'count' FROM `" + STATICS_TABLE + "` WHERE id like '%" + search + "%'";
                    let result = connection.query(query, function (err, rows) {
                        for (let i = 0; i < rows.length; i++) {
                            callback(null, rows[i].count);
                        }
                    });
                },
                function (callback) {
                    let query = "SELECT * FROM (SELECT `u`.* FROM ( " +
                        "SELECT IF(@score > `HT`.rank, @cur := @cur+1, @cur) AS 'sq', @score := `HT`.rank, `HT`.* " +
                        "FROM `" + TODAY_TABLE + "` HT, (SELECT @cur := 0, @score := 5000) t " +
                        "ORDER BY `rank` DESC) u ) uu " +
                        "WHERE `uu`.id like '%" + search + "%' LIMIT " + start + "," + end;
                    // console.log(query);

                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            callback(err, null);
                        }
                        let currentTime = new Date().getTime() / 1000 | 0;

                        for (let i = 0; i < rows.length; i++) {
                            let temp = {
                                seq: rows[i].sq,
                                id: rows[i].id.toDisplayID(),
                                role: rows[i].role,
                                team: rows[i].team,
                                profile: JSON.parse(rows[i].profile),
                                competitive: JSON.parse(rows[i].competitive),
                                quickplay: JSON.parse(rows[i].quickplay),
                                competitive_global: (rows[i].competitive_global) ? JSON.parse(rows[i].competitive_global) : "",
                                quickplay_global: (rows[i].quickplay_global) ? JSON.parse(rows[i].quickplay_global) : "",
                                timestamp: " " + getTimeStampString(currentTime - rows[i].timestamp),
                                summary_icon: rows[i].summary_icon,
                                portrait: "",
                                competitive_portrait: "",
                                quickplay_portrait: "",
                                hasCompetitive: false,
                            }
                            if (temp.competitive.order[0] !== undefined) {
                                temp.competitive_portrait = temp.competitive.data[temp.competitive.order[0].name].portrait;
                            }

                            temp.quickplay_portrait = temp.quickplay.data[temp.quickplay.order[0].name].portrait;
                            temp.portrait = temp.quickplay_portrait;

                            if (temp.profile.rank > 0) {
                                temp.portrait = temp.competitive.data[temp.competitive.order[0].name].portrait;
                                temp.hasCompetitive = true;
                            }

                            data.data.push(temp);
                        }
                        callback(null, data);
                    });
                }
            ],
            function (err, results) {

                data.recordsTotal = results[0];
                data.recordsFiltered = results[1];
                callback(null, data);
            }
        );
    }

    self.getStaticsRangeByName = (ids, draw, start, end, search, callback) => {
        console.log('getStaticsRangeByName ' + start + '-' + end + " : " + search);
        //console.dir(ids , {colors:true});

        let data = {
            "draw": draw,
            "recordsTotal": 0,
            "recordsFiltered": 0,
            data: []
        };

        let query = "SELECT `" + STATICS_TABLE + "`.*, IFNULL(`summary`.image,'') as 'summary_icon' ,`COUNT_TABLE`.`count` AS 'count', `S_COUNT_TABLE`.`count` AS 's_count' FROM `" + STATICS_TABLE + "` LEFT JOIN `summary` ON `" + STATICS_TABLE + "`.`id` = `summary`.`nick`, (SELECT COUNT(*) AS 'count' FROM `" + STATICS_TABLE + "` WHERE `" + STATICS_TABLE + "`.`id` LIKE '%" + search + "%') `S_COUNT_TABLE`,(SELECT COUNT(*) AS 'count' FROM `" + STATICS_TABLE + "`) `COUNT_TABLE` WHERE `" + STATICS_TABLE + "`.`id` LIKE '%" + search + "%' ";
        query = query + "AND `" + STATICS_TABLE + "`.nick in (";

        var temp = "";
        for (var i in ids) {
            temp = temp + "'" + ids[i] + "',";
        }
        temp = temp.substring(0, (temp.length) - 1);

        query = query + temp;
        query = query + ")"
        query = query + " order by cast(`rank` as unsigned) desc LIMIT " + start + "," + end;

        //console.log(query);

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }
            let currentTime = new Date().getTime() / 1000 | 0;

            for (let i = 0; i < rows.length; i++) {
                let temp = {
                    nick: rows[i].nick,
                    role: rows[i].role,
                    team: rows[i].team,
                    profile: JSON.parse(rows[i].profile),
                    competitive: JSON.parse(rows[i].competitive),
                    quickplay: JSON.parse(rows[i].quickplay),
                    timestamp: " " + getTimeStampString(currentTime - rows[i].timestamp),
                    summary_icon: rows[i].summary_icon,
                    portrait: "",
                }
                temp.portrait = temp.competitive.data[temp.competitive.order[0].name].portrait;

                data.recordsTotal = rows[i].count;
                data.recordsFiltered = rows[i].s_count;
                data.data.push(temp);
            }

            callback(null, data);
        });
    }


    self.updatePollQuery = (id, poll, callback) => {

        let query = "UPDATE `" + STATICS_TABLE + "` SET `poll` = " + poll + " WHERE `" + STATICS_TABLE + "`.`id` = '" + id + "'";

        console.log(query);

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }
            callback(null, {});
        });
    }

    /**
     * 사용자 전적 갱신용 API
     */

    self.requestRefreshStatics = (nick, callback) => {

        console.log('전적갱신 [ ' + nick + '] ');
        nick = nick.toRequestID();
        async.series([
            function (cb) {
                getUserInfo(nick)
                    .then(function (data) {
                        cb(null, data);
                    })
                    .catch(function (error) {
                        cb(err, null);
                    });
            },
            function (cb) {
                let query = 'SELECT * FROM `' + STATICS_TABLE + '` ' +
                    'WHERE `' + STATICS_TABLE + '`.`id` = "' + nick + '"';

                var output = syncSql.select(db_info, query);
                if (output.success) {
                    cb(null, output.success);
                } else {
                    cb({
                        success: false,
                        message: "전적갱신 실패 : 사용자정보없음."
                    }, null);
                }
            },
            function (cb) {
                self.getViewStaticsWithHistory(nick, function (err, results) {
                    cb(null, results);
                });
            }
        ], function (error, results) {
            usersCommit(nick, results[0], function (err, results) {
                if (err) callback(err, null);
            });

            callback(null, results[2]);
        });
    }

    /**
     * 팀 리스트 조회
     */

    self.getTeamListInfo = () => {

        return new Promise((resolve, reject) => {

            let query = "SELECT teamid, teamname, teamleader, teamlogo, `UT`.`count` FROM ?? TT , (SELECT COUNT(*) as 'count', `UT`.`team` FROM ?? UT GROUP BY `UT`.`team`) UT WHERE `TT`.`teamid` = `UT`.`team` ";

            let response = [];

            connection.query(query, [TEAMINFO_TABLE, STATICS_TABLE])
                .on('result', function (result, index) {
                    response.push(result);
                })
                .on('error', reject)
                .on('end', function () {
                    resolve(response);
                });

        });

    }

    /**
     *  팀 세부정보 조회
     */
    self.getTeamDetailInfo = (teamid, callback) => {
        console.log('상세정보 ' + teamid);
        var response = {
            team_info: "",
            team_member_info: "",
            team_activity: "",
        }

        async.parallel([
                function (cb) {
                    let query = "SELECT * FROM `" + TEAMINFO_TABLE + "`,  (SELECT COUNT(*) as 'members' FROM `users` WHERE `team`=" + teamid + ") C WHERE `teamid` = " + teamid;
                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            cb({
                                success: false,
                                message: "팀정보를 찾을 수 없습니다."
                            }, null);
                            return;
                        }
                        cb(null, rows[0])
                    });
                },

                function (cb) {
                    let query = "SELECT * FROM `" + TEAMINFO_TABLE + "` TT INNER JOIN (SELECT UT.*, IT.profile, IT.`competitive_global`, IT.`quickplay_global`, IT.`competitive`, IT.`quickplay` FROM `" + STATICS_TABLE + "` UT , `" + TODAY_TABLE + "` IT WHERE `UT`.id = `IT`.id) MI ON `TT`.teamid = `MI`.team WHERE TT.teamid = '" + teamid + "'";
                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            cb({
                                success: false,
                                message: "팀정보를 찾을 수 없습니다."
                            }, null);
                            return;
                        }
                        cb(null, rows)
                    });
                },
                function (cb) {
                    let query = "SELECT * FROM `" + TEAMACTIVITY_TABLE + "` AS AT,  `" + STATICS_TABLE + "` AS UT WHERE `AT`.`action_to` = '" + teamid + "' AND `AT`.`action_from` = `UT`.`id` AND `AT`.`action` = 1";
                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            cb({
                                success: false,
                                message: "팀정보를 찾을 수 없습니다."
                            }, null);
                            return;
                        }
                        cb(null, rows)
                    });
                },
            ],

            function (error, results) {
                if (error) {
                    callback(error);
                    return;
                }
                response.team_info = results[0];
                response.team_member_info = results[1];
                response.team_activity = results[2];
                callback(null, response);
            });

    }

    /**
     *  팀 가입요청
     */
    self.requestTeamJoin = (userid, teamid, action, callback) => {
        console.log('팀 가입요청 [ ' + userid + "/" + teamid + " ]");
        let query = "REPLACE INTO `" + TEAMACTIVITY_TABLE + "` (`action`, `action_from`, `action_to`, `timestamp`) VALUES ('" + action + "', '" + userid + "', '" + teamid + "', '" + (new Date().getTime()) + "');";
        var output = syncSql.mysql(db_info, query);
        if (output.success) {
            callback(null, output.data.rows);
        } else {
            callback({
                success: false,
                message: "가입요청을 할 수 없습니다."
            }, null);
        }
    }

    /**
     *  팀 가입요청
     */
    self.getTeamJoinRequest = (teamid, callback) => {
        console.log('팀 가입요청 확인 [ ' + teamid + " ]");
        let query = "SELECT * FROM `" + TEAMACTIVITY_TABLE + "` AS AT,  `" + STATICS_TABLE + "` AS UT WHERE `AT`.`action_to` = '" + teamid + "' AND `AT`.`action` = 1 AND `AT`.`action_from` = `UT`.`id`";

        let output = syncSql.mysql(db_info, query);
        if (output.success) {
            callback(null, output.data.rows);
        } else {

            callback({
                success: false,
                message: "팀정보를 찾을 수 없습니다."
            }, null);
        }
    }

    /**
     *  팀 가입승인
     */
    self.acceptJoinTeam = (user_id, team_id, callback) => {
        console.log('팀 승인 [ ' + user_id + "/" + team_id + " ]");
        let query = "UPDATE `" + STATICS_TABLE + "` SET `team` = '" + team_id + "' WHERE `" + STATICS_TABLE + "`.`id` = '" + user_id + "'";
        let output = syncSql.mysql(db_info, query);
        if (!output.success) {
            callback({
                success: false,
                message: "승인에 실패했습니다."
            }, null);
        }

        let activity_query = "UPDATE `" + TEAMACTIVITY_TABLE + "` SET `action` = 2 WHERE action_from = '" + user_id + "' AND action = 1";

        let activity_output = syncSql.mysql(db_info, activity_query);
        if (!activity_output.success) {
            callback({
                success: false,
                message: "승인에 실패했습니다."
            }, null);
        }
        self.getTeamJoinRequest(team_id, callback);
    }

    // utility functions

    let usersCommit = (nick, data, callback) => {
        console.log('사용자 db 입력 [ ' + nick + ' ]');
        let currentTime = new Date().getTime() / 1000 | 0;

        let profile = JSON.stringify(data.users.profile).trim().replace(/\'/g, "_");
        let competitive_global = JSON.stringify(data.users.competitive_global).trim().replace(/\'/g, "_");
        let competitive = JSON.stringify(data.users.competitive).trim().replace(/\'/g, "_");
        let quickplay_global = JSON.stringify(data.users.quickplay_global).trim().replace(/\'/g, "_");
        let quickplay = JSON.stringify(data.users.quickplay).trim().replace(/\'/g, "_");
        let rank = isNaN(data.users.profile.rank) || data.users.profile.rank === undefined ? 0 : data.users.profile.rank;

        async.series([
                function (callback) {
                    let query =
                        'SELECT * FROM `' + STATICS_TABLE + '` UT ' +
                        "WHERE `UT`.`id` = '" + nick + "'";

                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            callback(err, null);
                        }
                        let insert_data = {
                            user_id: nick,
                            user_role: rows[0] === undefined ? 1 : rows[0].role,
                            user_team: rows[0] === undefined ? 0 : rows[0].team,
                            user_pin: rows[0] === undefined ? 0 : rows[0].pin,
                            user_avatar: data.users.profile.avatar === undefined ? "" : data.users.profile.avatar,
                            poll: rows[0] === undefined ? 0 : rows[0].poll,
                        }

                        let insert_query = "REPLACE INTO `" + STATICS_TABLE + "` (id, role, team,pin, avatar, poll) " +
                            " VALUES('" +
                            insert_data.user_id + "'," +
                            insert_data.user_role + ", " +
                            insert_data.user_team + ", " +
                            "'" + insert_data.user_pin + "', " +
                            "'" + insert_data.user_avatar + "', " +
                            insert_data.poll + ");";

                        let result = connection.query(insert_query, function (error, rows) {
                            if (error) {
                                callback(error, null);
                            } else {
                                callback(null, nick);
                            }
                        });
                    });
                },
                function (callback) {
                    let query =
                        'REPLACE INTO `' + TODAY_TABLE + '` (id, rank, profile, competitive_global, quickplay_global, competitive,quickplay,timestamp, date)' +
                        'values (' + "'" + nick + "'," + rank + ",'" + profile + "'," +
                        "'" + competitive_global + "'," + "'" + quickplay_global + "'," + "'" + competitive + "'," + "'" + quickplay + "'," +
                        "'" + currentTime + "' ," +
                        " CURDATE() )";

                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            callback(err, null);
                        } else {
                            callback(null, data);
                        }
                    });
                }
            ],
            function (err, results) {
                callback(null, results[1]);
                // console.log(' REPLACE [ ' + results[0] + ' ] ');
            }
        )

    }

    let historyCommit = (nick, callback) => {

        let info_query = "SELECT * FROM `" + TODAY_TABLE + "` WHERE `id` ='" + nick + "'";

        let info_query_result = connection.query(info_query, function (err, rows) {
            if (err) {
                return callback(err, null);
            }
            if (rows.length == 0) {
                return callback({
                    status: 0,
                    message: "user not found"
                });
            }
            let profile = rows[0].profile;
            let competitive_global = rows[0].competitive_global;
            let competitive = rows[0].competitive;
            let quickplay_global = rows[0].quickplay_global;
            let quickplay = rows[0].quickplay;
            let rank = rows[0].rank;
            let currentTime = new Date().getTime() / 1000 | 0;

            let query = 'REPLACE INTO `' + HISTORY_TABLE + '` ' +
                '(`id`,`seq`, `rank`, `profile`, `competitive_global`, `quickplay_global`, `competitive`, `quickplay`, `date`, `timestamp`) ' +
                'VALUES (' + "'" + nick + "'," +
                "(SELECT `U`.sq FROM " +
                "( SELECT IF(@score > `bt`.`rank`, @cur := @cur+1, @cur) AS 'sq', @score := `bt`.rank, `bt`.`id` " +
                "FROM `" + TODAY_TABLE + "` bt, (SELECT @cur := 0, @score := 5000) t " +
                "ORDER BY `bt`.`rank` DESC) U " +
                "WHERE `U`.`id` = '" + nick + "' )," +
                rank + ',' +
                "'" + profile + "'," +
                "'" + competitive_global + "'," +
                "'" + quickplay_global + "'," +
                "'" + competitive + "'," +
                "'" + quickplay + "'," +
                " DATE_ADD(CURDATE(), INTERVAL -1 DAY) ," +
                "'" + currentTime + "'); ";

            // console.log(query);

            let result = connection.query(query, function (err, rows) {
                if (err) {
                    return callback(err, null);
                }

                let delete_query = "DELETE FROM `" + HISTORY_TABLE + "` WHERE `id` = '" + nick + "' AND `date` IN (" +
                    "SELECT date FROM ( SELECT date FROM `" + HISTORY_TABLE + "` WHERE `id` = '" + nick + "' ORDER BY `date` DESC LIMIT " + HISTORY_STACK + ", 100) x )";

                let delete_result = connection.query(delete_query, function (err, row) {
                    if (err) {
                        return callback(err, null);
                    }
                    console.log(' ADD HISTORY [ ' + nick + ' ] ');
                    // callback(null, data);
                    return callback();
                });
            });
        });
    }



    // db refresh
    self.storeHistory = (callback) => {

        let query = "SELECT `" + STATICS_TABLE + "`.* FROM `" + STATICS_TABLE + "`";

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }

            var lookup_list = [];
            for (let i = 0; i < rows.length; i++) {
                lookup_list.push(rows[i].id);
            }
            var async = require('async');

            async.eachSeries(lookup_list, historyCommit, function (err) {
                // async.each(lookup_list, search_function, function (err) {
                if (err) {
                    console.log(err);
                } else {

                    // let query = [
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`rank` as unsigned) desc limit 1) WHERE `tag` = 'rank';",
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`damage` as unsigned) desc limit 1) WHERE `tag` = 'damage';",
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`heal` as unsigned) desc limit 1) WHERE `tag` = 'heal';",
                    // ];
                    // async.eachSeries(query, sql_function, function (err) {
                    //     if (err) callback(err, null);
                    callback(null, 'finish');
                    // });
                }
            });
        });
    }
    self.databaseRefresh = (callback) => {
        var lookup_list = [];
        let query = "SELECT `" + STATICS_TABLE + "`.* FROM `" + STATICS_TABLE + "`";

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }

            for (let i = 0; i < rows.length; i++) {
                lookup_list.push(rows[i].id);
            }

            var async = require('async');

            // connection.connect(function (err) {
            //     if (err) {
            //         console.log(err);
            //     }
            // });

            async.eachSeries(lookup_list, docsRefreshFunction, function (err) {
                // async.each(lookup_list, search_function, function (err) {
                if (err) {
                    console.log(err);
                } else {

                    // let query = [
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`rank` as unsigned) desc limit 1) WHERE `tag` = 'rank';",
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`damage` as unsigned) desc limit 1) WHERE `tag` = 'damage';",
                    //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`heal` as unsigned) desc limit 1) WHERE `tag` = 'heal';",
                    // ];
                    // async.eachSeries(query, sql_function, function (err) {
                    //     if (err) callback(err, null);
                    callback(null, 'finish');
                    // });
                }
            });
        });

    }

    // google docs
    self.googleDocsRefresh = (callback) => {

        var fs = require('fs');
        var readline = require('readline');
        var google = require('googleapis');
        var googleAuth = require('google-auth-library');

        // If modifying these scopes, delete your previously saved credentials
        // at ~/.credentials/sheets.googleapis.com-nodejs-quickstart.json
        var SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];
        var TOKEN_DIR = './.credentials/';
        var TOKEN_PATH = TOKEN_DIR + 'sheets.googleapis.com-nodejs-quickstart.json';

        // Load client secrets from a local file.
        fs.readFile('client_secret.json', function processClientSecrets(err, content) {
            if (err) {
                console.log('Error loading client secret file: ' + err);
                return;
            }
            // Authorize a client with the loaded credentials, then call the
            // Google Sheets API.
            authorize(JSON.parse(content), listMajors);
        });

        /**
         * Create an OAuth2 client with the given credentials, and then execute the
         * given callback function.
         *
         * @param {Object} credentials The authorization client credentials.
         * @param {function} callback The callback to call with the authorized client.
         */
        function authorize(credentials, callback) {
            var clientSecret = credentials.installed.client_secret;
            var clientId = credentials.installed.client_id;
            var redirectUrl = credentials.installed.redirect_uris[0];
            var auth = new googleAuth();
            var oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);

            // Check if we have previously stored a token.
            fs.readFile(TOKEN_PATH, function (err, token) {
                if (err) {
                    getNewToken(oauth2Client, callback);
                } else {
                    oauth2Client.credentials = JSON.parse(token);
                    callback(oauth2Client);
                }
            });
        }

        /**
         * Get and store new token after prompting for user authorization, and then
         * execute the given callback with the authorized OAuth2 client.
         *
         * @param {google.auth.OAuth2} oauth2Client The OAuth2 client to get token for.
         * @param {getEventsCallback} callback The callback to call with the authorized
         *     client.
         */
        function getNewToken(oauth2Client, callback) {
            var authUrl = oauth2Client.generateAuthUrl({
                access_type: 'offline',
                scope: SCOPES
            });
            console.log('Authorize this app by visiting this url: ', authUrl);
            var rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question('Enter the code from that page here: ', function (code) {
                rl.close();
                oauth2Client.getToken(code, function (err, token) {
                    if (err) {
                        console.log('Error while trying to retrieve access token', err);
                        return;
                    }
                    oauth2Client.credentials = token;
                    storeToken(token);
                    callback(oauth2Client);
                });
            });
        }

        /**
         * Store token to disk be used in later program executions.
         *
         * @param {Object} token The token to store to disk.
         */
        function storeToken(token) {
            try {
                fs.mkdirSync(TOKEN_DIR);
            } catch (err) {
                if (err.code != 'EEXIST') {
                    throw err;
                }
            }
            fs.writeFile(TOKEN_PATH, JSON.stringify(token));
            console.log('Token stored to ' + TOKEN_PATH);
        }

        /**
         * Print the names and majors of students in a sample spreadsheet:
         * https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit
         * https://docs.google.com/spreadsheets/d/1gf1Qq6U6jJwT2C2I5vw7WZvxG9uABMrY8xfN-kAJx98/edit#gid=416384871
         */
        function listMajors(auth) {
            var sheets = google.sheets('v4');
            sheets.spreadsheets.values.get({
                auth: auth,
                spreadsheetId: '1gf1Qq6U6jJwT2C2I5vw7WZvxG9uABMrY8xfN-kAJx98',
                range: 'BattleTag!A2:E',
            }, function (err, response) {
                if (err) {
                    console.log('The API returned an error: ' + err);
                    return;
                }
                var rows = response.values;
                if (rows.length == 0) {
                    console.log('No data found.');
                } else {

                    var lookup_list = [];
                    let query = "SELECT `" + STATICS_TABLE + "`.* FROM `" + STATICS_TABLE + "`";

                    let result = connection.query(query, function (err, rows) {
                        if (err) {
                            callback(err, null);
                        }

                        for (let i = 0; i < rows.length; i++) {
                            lookup_list.push(rows[i].id);
                        }


                        console.log('get google docs sheet rows');

                        for (var i = 0; i < rows.length; i++) {
                            var row = rows[i];
                            // Print columns A and E, which correspond to indices 0 and 4.
                            //console.log('%s', row[0]);
                            if (!(lookup_list.contains(row[0]))) {
                                lookup_list.push();
                            }
                        }

                        var fs = require('fs');
                        fs.unlink('./failed.txt', function (err) {
                            if (err) console.log(err);

                        });

                        var async = require('async');

                        // connection.connect(function (err) {
                        //     if (err) {
                        //         console.log(err);
                        //     }
                        // });

                        async.eachSeries(lookup_list, docsRefreshFunction, function (err) {
                            // async.each(lookup_list, search_function, function (err) {
                            if (err) {
                                console.log(err);
                            } else {

                                // let query = [
                                //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`rank` as unsigned) desc limit 1) WHERE `tag` = 'rank';",
                                //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`damage` as unsigned) desc limit 1) WHERE `tag` = 'damage';",
                                //     "UPDATE `summary` SET `nick` = (SELECT nick FROM `statics` order by cast(`heal` as unsigned) desc limit 1) WHERE `tag` = 'heal';",
                                // ];
                                // async.eachSeries(query, sql_function, function (err) {
                                //     if (err) callback(err, null);
                                callback(null, 'finish');
                                // });
                            }
                        });
                    });
                }
            });
        }
    }

    let sql_function = function (query, cb) {
        console.log(query);
        let result = connection.query(query, function (err, rows) {
            if (err) return cb(err);

            return cb();
        });
    }

    let docsRefreshFunction = (nick, callback) => {

        console.log('USER REFRESH ID [ ' + nick + ' ]');
        nick = nick.replace("#", "-");

        getUserInfo(nick)
            .then((data) => {
                if (nick) {
                    usersCommit(nick, data, function (err, results) {
                        // do nothing
                    });
                }
                return callback();

            }, function (error) {
                var fs = require('fs');
                fs.appendFile('./failed.txt', nick + '\n' + err + '\n', function (error) {
                    if (error) console.log('file write failed');
                });
                return callback();
            })
            .catch(function (error) {
                var fs = require('fs');
                fs.appendFile('./failed.txt', nick + '\n' + error + '\n', function (error) {
                    if (error) console.log('file write failed');
                });
                return callback();
            });

    }

    // rank chart
    self.getRankDataSets = (callback) => {
        let query = "SELECT " +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 0 and 500) as '0'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 500 and 1000) as '500'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 1000 and 1500) as '1000'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 1500 and 2000) as '1500'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 2000 and 2500) as '2000'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 2500 and 3000) as '2500'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 3000 and 3500) as '3000'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 3500 and 4000) as '3500'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 4000 and 4500) as '4000'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 4500 and 5000) as '4500'," +
            "(SELECT COUNT(*) FROM `" + STATICS_TABLE + "` WHERE `rank` BETWEEN 5000 and 5001) as '5000'"

        let result = connection.query(query, function (err, rows) {
            if (err) {
                callback(err, null);
            }

            var data = [];
            for (let i = 0; i < rows.length; i++) {

                for (var k in rows[i]) {
                    data.push([parseInt(k), rows[i][k]]);
                }

            }
            var datasets = {
                label: "경쟁전점수",
                color: "#4fb9f0",
                data: data,
            };
            callback(null, datasets);

        });
    }
}

module.exports = new StaticsProvider();
